\subsubsection{Data Path} \label{fpga:fitness:sss:data_path}
The design of the fitness core is highly influenced by the classic pipelined MIPS core design\cn.
The core is designed as a five stage pipeline.
The contents of the different stages in the pipeline, however, differs from the original MIPS architecture, as the CPU architecture has to accomadate for the ISA design which combines ideas from multiple exisiting architectures.
An overview of the data path can be seen in figure \vref{fpga:fig:fitness:fitness_arch}

\input{fpga/fig/fitness_architecture}.

The data path is simple.
The instruction is the same length for all the instructions.
This makes it easier to fetch the instruction in the first stage and decode it in the second.
Also, the ISA only supports three different instructions classes with the register mappings located on the same positions.
This allows the register file to be read on the same time as the control unit determines the correct control signals for that particular instruction.
This allows for a shorter pipeline.
If the instruction format where not symmetric, we would need to split the register file and decode stage in two stages.
A bigger pipeline would imply higher risk for pipeline hazards, and a more complicated hazard detection and correction schemes. 

The data path is in fact a load/store architecture.
This simplifies the execution and memory interaction.
Note that memory operands only appear in load and store instructions.
This implies that the execution stages is responsible for calculating the memory address and that the memory access can happen in the following stage.
Allowing the ALU to operate on operands in memory would expand the address stage, memory stage and the execution stage \cite[p.~335]{compOrgDes}.
The resulting architecture would involve a deeper pipeline. 


The MIPS inspired pipeline allows the design to be simple, but still powerful.
It  will increase performance by effectively increasing the instruction throughput.
Note that instruction throughput is an important metric because real applications execute millions of instructions \cite[p.~335]{compOrgDes}



More advanced features like branch prediction and instruction scheduling are not taken into consideration while designing the data path.
The group decided that the overall design should be as simple as possible.
Hazard and branching schemes are kept simple.
Hazards are resolved with the \emph{forwarding unit}, which forwards data if dependencies are detected.
Branching are resolved with use of \emph{conditional} codes in each instructions.
The reader may refer to their respective sections for more details.



\subsubsection{Control Unit} \label{fpga:fitness:sss:control_unit}
The responsibility of the control unit is to configure all the different components for the current CPU operation so that the desired computation will emerge from the flow of data.
The control unit achieves this by setting the control signals of the relevant control signals of the relevant components to the values associated with the current instruction.
Note that different instructions classes requires different use of the data path.
Thus, combinations the control signals must accommodate the different instructions formats. The different instructions classes and their control can be seen in table \ref{fpga:fitness:control_unit_out_tbl}. 

The control unit sets up the components based on the \emph{FUNCTION CODE} and the \emph{OPERATION CODE} of the instruction. The \emph{FUNCTION CODE} is the 4 least significant bits of the instruction, and is responsible for determining the operation the ALU should perform. An overview of the different ALU operations can be found in table .

 
\input{fpga/tbl/alu_function_codes_tbl}

\input{fpga/tbl/opcode_tbl}



\input{fpga/tbl/control_unit_output_tbl}

\input{fpga/tbl/control_signals_meaning_tbl}





\input{fpga/tbl/fitness_core_control_unit_tbl}


%%The meaning of the different control signals

\subsubsection{ALU\_FUNC}
The \emph{ALU\_FUNC} is the least four significant bits of the instruction, and is responsible for determining the type of operation the \emph{ALU} should perform. This are set according to table \ref{fpga:tbl:alu_function_codes_tbl} 


\subsubsection{ALU\_SOURCE}
The \emph{ALU\_SOURCE} signal is used to specify the second \emph{ALU operand}. When this signal is asserted the second ALU operand is the immediate field of the instruction. This implies that the instruction class of the instruction is either RRI or RI. On the other hand, if this signal is de-asserted, the operand comes from read register to of the instruction file. Note that this value may or may not have been forwarded. 

\subsubsection{REG\_WRITE}
This signals specifies whether the value, residing in the \emph{write-back} stage, should be written to the register file. When this signal is asserted the value from the \emph{write-back} stage is written to the specified register address. The register address is specified in the instruction, and always reside in the RT address field of the instruction. This fact makes it simpler when deciding at what address the value should be written. However, when this signal is de-asserted, this is equivalent with no operation. 

\subsubsection{IMM\_SOURCE}
The galapagos ISA have two different instruction classes (RI, RRI) that uses different lengths of the immediate field. In order to differentiated between these immediate fields, the \emph{IMM\_SOURCE} signal is responsible of selecting immediate field based on the instruction class of the current instruction. The selection is done with a multiplexor. In case of an RRI instruction the 10-bits immediate field is selected, and the 19-bits for a RI instruction.   


\subsubsection{REG\_SOURCE}
\todo {this}





\subsubsection{STORE\_SOURCE}
\todo{this}

\subsubsection{JUMP}
The jump instruction is use the address in the immediate field of the instruction to load a new value into the \emph{program counter} register. Which specifies the address of the next instruction to be executed. The jump signal is used in a multiplexor in the memory stage to select between the jump address or the incremented program counter. In case of jump, this signal is asserted and the jump address is chosen. When de-asserted the program counter is the incremented program counter. This signal is also asserted when performing call instructions which is discussed in the section below.   

\subsubsection{CALL}
MIPS operate with what is known as a \emph{link-and-jump} instruction in order to support function calls \cn. The galapagos ISA also support this functionality, however, the instruction is denoted as \emph{CALL} instead of \emph{JAL}. The instruction works very similar to the jump instruction described above. The difference lay in the fact that the incremented program counter is stored in combination with the program counter being modified. This address is stored in register 31.This value can be used later when returning from the function call. The return of a function is basically a jump instruction that jumps back to the address after the call instruction.

The responsibility of the \emph{CALL} signal is to make sure that the incremented program counter is stored at register 31. When asserted the signal make sure that the write register address is changed to 31. If the signal is de-asserted the write register will stay unmodified, and the RT register in the instruction is responsible for specifying the register address.


\subsubsection{GENE\_OP}
The loading and storing fitness values and chromosomes is the responsibility of the \emph{genetic controller}. This controller is able to perform three types of actions: \emph{load}, \emph{store} and \emph{settings} dependent of the instruction class executed. When performing a load, a chromosome is loaded from the unrated pool. The store operation is used to store a chromosome and its corresponding fitness value to the rated pool. The settings are used to apply settings to the genetic pipeline.  In order to divide these cases, the galapagos architecture rely on \emph{gene operation} vector. The bit-vector is set depending on the instruction class as seen in table \ref{fpga:tbl:gene_op_code_tbl}



\input{fpga/tbl/gene_op_code_tbl}

Depending on the bit-vector-signal, the \emph{genetic controller} is able to perform the appropriate action. 

\todo{Fix} 

\subsubsection{MEM\_OP}
As with the genetic controller, the memory controller must be able to distinguish between operations. In case of memory controller, these operations are loading and storing to/from the external memory. In same manner as with, the genetic controller, these signals are set according to the instruction class currently being executed. These can be seen in table \ref{fpga:tbl:mem_op_code_tbl}

\input{fpga/tbl/mem_op_code_tbl}


\subsubsection{TO\_REG}
In the \emph{write-back} stage, there is need to distinguish between several outputs from the \emph{memory stage}. The \emph{TO\_REG} signal is responsible for selecting which value that should be written to the register file. The selection is aided by a 4-to-1 multiplexor. The different inputs are: \emph{Gene}, \emph{Data}, and \emph{PC+1}, \emph{Res}, as seen in figure \todo{add reference}. However, keep in mind that the \emph{REG\_WRITE} signals must be asserted for the data to be written. 

The \emph{TO\_REG} bit-vector are set according to table \ref{fpga:tbl:to_reg_multiplexor_output_tbl}

\input{fpga/tbl/to_reg_multiplexor_output_tbl}





\subsubsection{The ALU}\label{fpga:fitness:sss:the_alu}

\subsubsection{Forwarding Unit} \label{fpga:fitness:sss:forwarding_unit}
Since the executions of instructions overlap in the pipeline.
There is need for some mechanism to handle the data dependencies that arise between the instructions. These dependencies are known as data hazards. They occur when a planned execution of an instruction cannot happen in that cycle because some data is not yet available. This problem can be solved in two ways, either by stalling or forwarding. Stalling, the simplest solution, is done by avoiding the hazard by stalling until the data becomes available. This is accomplished by inserting \emph{NOPs} in the pipeline. Although, this method work, it is to slow in most cases. Since this processor aim to achieve high performance this solution is far from optional. A far better approach is to rely on forwarding, also known as register forwarding. In this approach the aim is to resolve the dependencies by simply forwarding internal resources from other stages in the pipeline, if needed.

The forwarding logic is implemented by comparing register dependencies of the instruction in the execution stage with other instructions currently residing in the pipeline. If the forwarding unit notices register dependencies and that these instructions will write to these registers at a later time, it will assert signals that causes the data to be forwarded to the execution stage. The control signals is used in two 3-to-1 multiplexors in order to choose which source the data should arrive from. An overview of the control signals and their meaning can be seen in table. \ref{tbl:fpga:forwarding_signals}.

\todo{Perhaps this can be rewritten a bit}


\input{fpga/tbl/forwarding_unit_tbl}



\subsubsection{Conditionals} \label{fpga:fitness:sss:conditionals}
Like ARM , the galapagos architecture use conditional codes in order to determine if an instruction should be executed or not. Instead of using explicit branch instructions each instruction carries a 4-bit conditional code. Every instruction is in fact executed, however, the effect of the instruction is determined by the \emph{condition unit}. The \emph{condition unit} is implemented by checking the condition code of the current instruction against the status flags of the previous instruction. Dependent on this information the \emph{condition unit} produces an \emph{execute signal}. This signal is used to either, invalidate or approve the current instruction. However, this may also alter instruction stream and cause more instructions to be invalidated. Note that the determination of the branch is performed during the memory stage. This implies      
that the instructions following the branch is loaded in the pipeline. If the branch is not taken, this does not impose a problem since the instruction were going to be validated anyway. However, if the branch is taken, the following instructions is not supposed to be validated. To avoid this the memory stage contain a counter which keep control of how many instructions that should be invalidated. The instructions themselves are simply invalidated by changing their conditional code to yield not executed. An overview of the conditional codes can be found in table \todo{reference} in appendix \todo{reference}.

\todo{Better flow}





\subsubsection{Memory Controller} \label{fpga:fitness:sss:memory_controller}

\subsubsection{Genetic Pool Controller} \label{fpga:fitness:sss:genetic_pool_controller}

\subsubsection{Case Study} \label{fpga:fitness:sss:case_study}



